var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Module-Documentation","page":"API Reference","title":"Module Documentation","text":"","category":"section"},{"location":"api/#AStarSearch.AStarSearch","page":"API Reference","title":"AStarSearch.AStarSearch","text":"AStarSearch\n\nA Julia package for efficient pathfinding and state-space search using the A* algorithm and uninformed search algorithms.\n\nMain Features\n\nGeneric A* implementation that works with any state type\nMemory-efficient implementation with optional closed set\nUninformed search algorithms (DFS, BFS, iterative deepening)\nCustomizable heuristic, cost, and neighbor functions\nSupport for timeout and maximum cost constraints\n\nExports\n\nMain function: astar\nHelper functions: defaultheuristic, defaultcost, defaultisgoal, reconstructpath\nTypes: AStarNode, AStarResult, UninformedSearchResult\nUninformed search: depthfirst, breadthfirst, iterative_deepening\n\n\n\n\n\n","category":"module"},{"location":"api/#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"api/#AStarSearch.AStarNode","page":"API Reference","title":"AStarSearch.AStarNode","text":"AStarNode{TState, TCost}\n\nA node in the A* search tree, containing the state data and search metadata.\n\nFields\n\ndata::TState: The actual state data this node represents\ng::TCost: The cost from start to this node\nf::TCost: The total estimated cost (g + h) through this node to goal\nparent::Union{AStarNode{TState, TCost}, Nothing}: The predecessor node in the search tree\n\n\n\n\n\n","category":"type"},{"location":"api/#AStarSearch.AStarResult","page":"API Reference","title":"AStarSearch.AStarResult","text":"AStarResult{TState, TCost}\n\nResult of an A* search, containing the solution path and search statistics.\n\nFields\n\nstatus::Symbol: Search result - :success, :timeout, or :nopath\npath::Vector{TState}: Sequence of states from start to goal (or best found)\ncost::TCost: Total cost of the path\nclosedsetsize::Int64: Number of states explored (size of closed set)\nopensetsize::Int64: Number of states still to explore when search ended\n\n\n\n\n\n","category":"type"},{"location":"api/#AStarSearch.UninformedSearchResult","page":"API Reference","title":"AStarSearch.UninformedSearchResult","text":"UninformedSearchResult{TState}\n\nResult of an uninformed search algorithm (depth-first, breadth-first, or iterative deepening).\n\nFields\n\nstatus::Symbol: Search result - :success, :timeout, or :nopath\npath::Vector{TState}: Sequence of states from start to goal (or best found)\nclosedsetsize::Int64: Number of states explored (size of closed set)\nopensetsize::Int64: Number of states still to explore when search ended\n\n\n\n\n\n","category":"type"},{"location":"api/#AStarSearch.astar-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.astar","text":"astar(neighbours, start, goal;         heuristic=defaultheuristic, cost=defaultcost, isgoal=defaultisgoal, hashfn=hash, timeout=Inf, maxcost=Inf)\n\nExecute the A* algorithm to get the best path from the start state to reach a goal condition. Only the first 3 arguments are mandatory, all the others are optional.\n\nIt returns a structure in which the status field is a Symbol that can be either:\n\n:success: the algorithm found a path from start to goal\n:timeout: the algorithm timed out, a partial path to the best state is returned in the path field\n:nopath: the algorithm didn't find any path to a goal, the path to the best state is still returned\n\nThe other fields are:\n\npath: an array of states from the start state to the goal or the best found state\ncost: the cost of the returned path\nclosedsetsize: how many states the algorithm tested if they were a goal (size of the closed set)\nopensetsize: how many states were still in the open set when the algorithm ended\n\nArguments\n\nneighbours: a function that takes a state and returns the neighbour states as an array (or iterable)\nstart: the starting state, the type of the state is completely unrestricted\ngoal: the goal state, the type is unrestricted, usually it's the same as the start\nheuristic: a function that given a state and the goal returns an estimate of the cost to reach goal. This estimate should be optimistic if you want to be sure to get the best path. Notice that the best path could be very expensive to find, so if you want a good but not guaranteed optimal path, you could multiply your heuristic by a constant, the algorithm will usually be much faster\ncost: a function that takes the current state and a neighbour and returns the cost to do that state transition. By default all transitions cost 1\nisgoal: a function that takes a state and the goal and evaluates if the goal is reached (by default ==)\nhashfn: a function that takes a state and returns a compact representation to use as dictionary key (usually one of UInt, Int, String), by default it is the base hash function. This is a very important field for composite states in order to avoid duplications. WARNING states with arrays as fields might return a different hash every time! If this is the case, please pass an hashfn that always returns the same value for the same state!\ntimeout: timeout in number of seconds after which the algorithm stops returning the best partial path to the state with the lowest heuristic, by default it is unrestricted. Please notice that the algorithm wil run AT LEAST the specified time.\nmaxcost: a maximum bound of the accumulated cost of the path, this can result in a :nopath result even if a path to the goal (with a greater cost) exists. By default it is Inf\nenable_closedset: keep track of already visited nodes to avoid visiting them again, you might want to disable this if you know there isn't any loop in the state space graph (by default true)\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.breadthfirst-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.breadthfirst","text":"Executes a breadth first search given the neightbours function, the start and goal state.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.defaultcost-Tuple{Any, Any}","page":"API Reference","title":"AStarSearch.defaultcost","text":"defaultcost(state, neighbor) -> Int64\n\nDefault cost function used by A* search. Returns 1 for any state transition, making all moves equally costly. Override this for weighted edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.defaultheuristic-Tuple{Any, Any}","page":"API Reference","title":"AStarSearch.defaultheuristic","text":"defaultheuristic(state, goal) -> Int64\n\nDefault heuristic function used by A* search. Always returns 0, effectively reducing A* to Dijkstra's algorithm (or Breadth-First Search with unit costs). Override this with a problem-specific heuristic for better performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.defaultisgoal-Tuple{Any, Any}","page":"API Reference","title":"AStarSearch.defaultisgoal","text":"defaultisgoal(state, goal) -> Bool\n\nDefault goal test function used by A* search. Uses == to compare states. Override this for custom goal conditions or pattern matching.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.depthfirst-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.depthfirst","text":"Execute a depth-first search given the neighbours function, a start and a goal. It takes the same parameters as astar, but it ignores those about cost and heuristic. Use the maxdepth parameter to limit the search to a certain depth.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.iterative_deepening-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.iterative_deepening","text":"Execute iteratively a depth first search starting from depth 0 to maxdepth.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.reconstructpath-Tuple{Any}","page":"API Reference","title":"AStarSearch.reconstructpath","text":"reconstructpath(node::AStarNode) -> Vector\n\nReconstructs the solution path by following parent pointers from the goal node back to the start node. Returns a vector of states in start-to-goal order.\n\nArguments\n\nnode: The final node (usually goal node) from which to reconstruct the path\n\nReturns\n\nVector of states representing the path from start to the final node\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isless-Tuple{AStarNode, AStarNode}","page":"API Reference","title":"Base.isless","text":"isless(n1::AStarNode, n2::AStarNode)\n\nCompare nodes by their f-values for priority queue ordering. Nodes with lower f-values (estimated total cost) are considered smaller.\n\n\n\n\n\n","category":"method"},{"location":"examples/15puzzle/#15-Puzzle-Example","page":"15-Puzzle","title":"15-Puzzle Example","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"The 15-puzzle is a classic sliding puzzle that consists of a 4Ã—4 grid with 15 numbered tiles and one empty space. The goal is to rearrange the tiles from a given starting configuration to reach a specific goal state by sliding tiles into the empty space.","category":"page"},{"location":"examples/15puzzle/#Problem-Setup","page":"15-Puzzle","title":"Problem Setup","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"First, we define the state structure and some helper functions:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"struct State\n    table::Array{Int8, 2}\nend\n\n# Define movement directions\nUP = CartesianIndex(-1, 0)\nDOWN = CartesianIndex(1, 0)\nLEFT = CartesianIndex(0, -1)\nRIGHT = CartesianIndex(0, 1)\nDIRECTIONS = [UP, DOWN, LEFT, RIGHT]\n\n# Goal state configuration\nGOALSTATE = State([\n    1  2  3  4\n    5  6  7  8\n    9  10 11 12\n    13 14 15 0\n])","category":"page"},{"location":"examples/15puzzle/#State-Manipulation","page":"15-Puzzle","title":"State Manipulation","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"We need functions to find valid moves and generate next states:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"# Find empty tile position\nemptyposition(s::State) = findfirst(x -> x == 0, s.table)\n\n# Check if a position is valid on the board\nisvalidindex(c) = (0 < c[1] < 5) && (0 < c[2] < 5)\n\n# Get available moves from current empty position\navailablemoves(e::CartesianIndex) = \n    [direction for direction in DIRECTIONS if isvalidindex(e + direction)]\navailablemoves(s::State) = s |> emptyposition |> availablemoves\n\n# Generate next states by applying available moves\nnextstates(s::State) = map(x -> move(s, x), availablemoves(s))","category":"page"},{"location":"examples/15puzzle/#Heuristic-Function","page":"15-Puzzle","title":"Heuristic Function","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"For efficient pathfinding, we use a combination of Manhattan distance and swap count:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"function heuristicmanhattanandswaps(s::State)\n    # Manhattan distance component\n    manhattan_sum = sum(manhattan(findfirst(x -> x == i, s.table), \n                                FINALSTATEINDEXES[i]) for i = 1:15)\n    \n    # Swap count component\n    swaps = countswaps(s)\n    \n    return manhattan_sum + 2*swaps\nend\n\n# For A* search interface\nheuristic(s, goal) = heuristicmanhattanandswaps(s)","category":"page"},{"location":"examples/15puzzle/#Solving-the-Puzzle","page":"15-Puzzle","title":"Solving the Puzzle","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"Now we can solve the puzzle using A* search:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"using AStarSearch\n\n# Example starting state\nstart = State([\n    1 2 3 4\n    5 7 11 8\n    9 6 0 12\n    13 10 14 15\n])\n\n# Find solution path\nresult = astar(nextstates, start, GOALSTATE; heuristic=heuristic)\n\nif result.status == :success\n    println(\"Solution found in $(result.cost) moves!\")\n    # Path contains the sequence of states from start to goal\n    for state in result.path\n        display(state.table)\n        println()\n    end\nelse\n    println(\"No solution found.\")\nend","category":"page"},{"location":"examples/15puzzle/#Performance-Considerations","page":"15-Puzzle","title":"Performance Considerations","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"For efficient state comparison and storage in the closed set, we provide a custom hash function that compresses the entire board state into a single 64-bit integer:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"function Base.hash(s::State)\n    h = UInt64(0)\n    for j = 1:4, i = 1:4\n        h += s.table[i, j]\n        h <<= 4\n    end\n    return h\nend","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"This example demonstrates how AStarSearch.jl can be used to solve complex puzzles while maintaining good performance through careful state representation and heuristic design.","category":"page"},{"location":"#AStarSearch.jl","page":"Home","title":"AStarSearch.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A generic implementation of the A* search algorithm and several uninformed search algorithms in Julia. The package provides tools for exploring state spaces efficiently using both informed (A*) and uninformed search strategies.","category":"page"},{"location":"#Understanding-A*-Search","page":"Home","title":"Understanding A* Search","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A* is a pathfinding and graph traversal algorithm that finds the shortest path between nodes in a graph. It achieves better performance than traditional approaches like Dijkstra's algorithm by using heuristics to guide its search.","category":"page"},{"location":"#Core-Concepts","page":"Home","title":"Core Concepts","text":"","category":"section"},{"location":"#State-Space-Exploration","page":"Home","title":"State Space Exploration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The algorithm works by exploring a state space, where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each state represents a configuration or position in your problem\nTransitions between states are determined by your neighbours function\nThe goal is to find an optimal path from start state to goal state","category":"page"},{"location":"#How-A*-Works","page":"Home","title":"How A* Works","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Open Set: Contains states to be explored, ordered by their estimated total cost\nClosed Set: Tracks already visited states to avoid cycles\nCost Function (g): Actual cost from start to current state\nHeuristic Function (h): Estimated cost from current state to goal\nTotal Estimated Cost (f): f = g + h","category":"page"},{"location":"","page":"Home","title":"Home","text":"At each step, A* selects the most promising state (lowest f value) from the open set, which guides the search toward efficient paths.","category":"page"},{"location":"#Algorithm-Properties","page":"Home","title":"Algorithm Properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Optimality: If the heuristic is admissible (never overestimates), A* guarantees the optimal path\nMemory Usage: Uses a closed set to avoid revisiting states (optional in this implementation)\nPerformance: Efficiency depends heavily on the quality of the heuristic function","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generic implementation that works with any state type\nFully customizable components:\nneighbours function for state space generation\nheuristic function for search guidance\ncost function for transition costs\nMemory efficient with optional closed set\nAdditional uninformed search algorithms:\nDepth-first search\nBreadth-first search\nIterative deepening","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AStarSearch\")","category":"page"},{"location":"#Implementation-Details","page":"Home","title":"Implementation Details","text":"","category":"section"},{"location":"#State-Space-Generation","page":"Home","title":"State Space Generation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The neighbours function is the core of state space generation. It takes a state and returns an iterable of adjacent states:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function neighbours(state)\n    # Generate and return all possible next states\n    # Example: for a grid, return adjacent cells\n    # Example: for a puzzle, return valid moves\n    return next_states\nend","category":"page"},{"location":"#Search-Guidance","page":"Home","title":"Search Guidance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Two key functions guide the search:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Heuristic Function","category":"page"},{"location":"","page":"Home","title":"Home","text":"function heuristic(current, goal)\n    # Estimate remaining cost to goal\n    # Must be admissible (never overestimate)\n    # Example: Manhattan distance for grid problems\n    return estimated_cost\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cost Function","category":"page"},{"location":"","page":"Home","title":"Home","text":"function cost(current, next)\n    # Actual cost of transition between states\n    # Example: Distance, time, or energy required\n    return transition_cost\nend","category":"page"},{"location":"#Using-the-Algorithm","page":"Home","title":"Using the Algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Basic usage with all optional parameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AStarSearch\n\nresult = astar(neighbours,      # State generation function\n               start_state,     # Initial state\n               goal_state;      # Target state\n               heuristic=h,     # Optional: guide search (default: 0)\n               cost=c,          # Optional: transition cost (default: 1)\n               hashfn=hash,     # Optional: state identification\n               timeout=Inf,     # Optional: time limit\n               maxcost=Inf)     # Optional: cost limit\n\n# Result contains:\n# - status: :success, :timeout, or :nopath\n# - path: Array of states from start to goal/best found\n# - cost: Total path cost\n# - closedsetsize: Number of explored states\n# - opensetsize: Remaining states to explore","category":"page"},{"location":"#Important-Implementation-Details","page":"Home","title":"Important Implementation Details","text":"","category":"section"},{"location":"#Hash-Function-and-State-Management","page":"Home","title":"Hash Function and State Management","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The hash function plays a crucial role in A*'s efficiency and correctness:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function hashfn(state)\n    # Return a stable, compact representation\n    # Usually one of: UInt, Int, String\n    return hash_value\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key considerations for hashfn:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Used for both open set lookups and closed set checking\nMust be fast (called frequently during search)\nMust return consistent values for equal states\nShould produce compact representations to save memory","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Julia Arrays and Hashing\nStates containing arrays require special attention. In Julia, the default hash  for structs with array fields may return different values for the same state  across multiple calls. Always provide a custom hashfn for such states that  ensures stable hashing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example of a stable hash function for a puzzle state:","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct PuzzleState\n    board::Matrix{Int}\nend\n\n# Custom hash that produces consistent values\nfunction Base.hash(state::PuzzleState, h::UInt)\n    # Convert board to a single number for stable hashing\n    value = 0\n    for (i, n) in enumerate(state.board)\n        value = value * 16 + n\n    end\n    return hash(value, h)\nend","category":"page"},{"location":"#Performance-vs-Optimality-Trade-offs","page":"Home","title":"Performance vs Optimality Trade-offs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A* guarantees optimal paths when using admissible heuristics, but you can trade optimality for speed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inflated Heuristics\n# Original admissible heuristic\nh(state, goal) = manhattan_distance(state, goal)\n\n# Inflated for speed (may not find optimal path)\nh_fast(state, goal) = 1.5 * manhattan_distance(state, goal)\nEarly Termination\nUse maxcost to limit path cost\nSet timeout for time-constrained searches\nBoth return best-effort paths when limits are hit\nMemory vs Speed\nenable_closedset=true (default): Prevents revisiting states\nenable_closedset=false: Uses less memory but may explore states multiple times\nConsider disabling closed set for tree-like state spaces with no cycles","category":"page"},{"location":"#Important-Considerations","page":"Home","title":"Important Considerations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Heuristic Design\nMust be admissible (never overestimate) for optimal paths\nMore accurate heuristics generally mean faster search\nCan be intentionally inflated to trade optimality for speed\nState Representation\nChoose state types that can be efficiently compared and hashed\nFor composite states, provide a custom hashfn\nArray-containing states need stable hash functions\nMemory Management\nClosed set prevents cycles but uses memory\nCan be disabled with enable_closedset=false\nConsider using maxcost to limit search space","category":"page"},{"location":"","page":"Home","title":"Home","text":"For detailed examples and specific use cases, check out the Examples section.","category":"page"},{"location":"examples/maze/#Maze-Pathfinding-Example","page":"Maze Pathfinding","title":"Maze Pathfinding Example","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"This example shows how to use AStarSearch.jl to solve a simple maze pathfinding problem. We'll represent the maze as a 2D grid where true represents walls and false represents open paths.","category":"page"},{"location":"examples/maze/#Problem-Setup","page":"Maze Pathfinding","title":"Problem Setup","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"We'll use CartesianIndex to represent positions in the maze:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"# Define movement directions\nUP = CartesianIndex(-1, 0)\nDOWN = CartesianIndex(1, 0)\nLEFT = CartesianIndex(0, -1)\nRIGHT = CartesianIndex(0, 1)\nDIRECTIONS = [UP, DOWN, LEFT, RIGHT]","category":"page"},{"location":"examples/maze/#Neighbor-Generation","page":"Maze Pathfinding","title":"Neighbor Generation","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"For each position in the maze, we need to generate valid neighboring positions:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"function mazeneighbours(maze, p)\n    res = CartesianIndex[]\n    for d in DIRECTIONS\n        n = p + d\n        # Check if neighbor is within bounds and not a wall\n        if 1 â‰¤ n[1] â‰¤ size(maze)[1] && \n           1 â‰¤ n[2] â‰¤ size(maze)[2] && \n           !maze[n]\n            push!(res, n)\n        end\n    end\n    return res\nend","category":"page"},{"location":"examples/maze/#Heuristic-Function","page":"Maze Pathfinding","title":"Heuristic Function","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"We'll use Manhattan distance as our heuristic:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"manhattan(p, s) = abs(p[1] - s[1]) + abs(p[2] - s[2])","category":"page"},{"location":"examples/maze/#Solving-the-Maze","page":"Maze Pathfinding","title":"Solving the Maze","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"Putting it all together:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"using AStarSearch\n\n# Create a maze (true = wall, false = path)\nmaze = [\n    0 0 1 0 0\n    0 1 0 0 0\n    0 1 0 0 1\n    0 0 0 1 1\n    1 0 1 0 0\n] .== 1\n\n# Define start and goal positions\nstart = CartesianIndex(1, 1)\ngoal = CartesianIndex(1, 5)\n\n# Helper function to solve the maze\nfunction solvemaze(m, s, g)\n    astar(p -> mazeneighbours(m, p), s, g; heuristic=manhattan)\nend\n\n# Find the path\nresult = solvemaze(maze, start, goal)\n\nif result.status == :success\n    println(\"Path found with length $(result.cost)!\")\n    # Print the path\n    for position in result.path\n        println(position)\n    end\nelse\n    println(\"No path found to goal!\")\nend","category":"page"},{"location":"examples/maze/#Visualizing-the-Solution","page":"Maze Pathfinding","title":"Visualizing the Solution","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"Here's a simple way to visualize the path in the maze:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"function printmaze(maze, path)\n    chars = fill('.', size(maze))\n    chars[maze] .= 'â–ˆ'\n    \n    # Mark the path with numbers\n    for (i, pos) in enumerate(path)\n        chars[pos] = '*'\n    end\n    \n    # Print the maze\n    for row in eachrow(chars)\n        println(join(row))\n    end\nend\n\n# Example visualization\nprintmaze(maze, result.path)","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"This will produce output like:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"*....\n*â–ˆ*.\n*â–ˆ*.â–ˆ\n**.â–ˆâ–ˆ\nâ–ˆ*â–ˆ..","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"This example demonstrates how AStarSearch.jl can be used for grid-based pathfinding problems. The same approach can be extended to more complex grids, different movement patterns, or custom cost functions.","category":"page"}]
}
