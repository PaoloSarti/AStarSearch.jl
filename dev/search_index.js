var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Module-Documentation","page":"API Reference","title":"Module Documentation","text":"","category":"section"},{"location":"api/#AStarSearch.AStarSearch","page":"API Reference","title":"AStarSearch.AStarSearch","text":"AStarSearch\n\nA Julia package for efficient pathfinding and state-space search using the A* algorithm and uninformed search algorithms.\n\nMain Features\n\nGeneric A* implementation that works with any state type\nMemory-efficient implementation with optional closed set\nUninformed search algorithms (DFS, BFS, iterative deepening)\nCustomizable heuristic, cost, and neighbor functions\nSupport for timeout and maximum cost constraints\n\nExports\n\nMain function: astar\nHelper functions: defaultheuristic, defaultcost, defaultisgoal, reconstructpath\nTypes: AStarNode, AStarResult, UninformedSearchResult\nUninformed search: depthfirst, breadthfirst, iterative_deepening\n\n\n\n\n\n","category":"module"},{"location":"api/#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"api/#AStarSearch.AStarNode","page":"API Reference","title":"AStarSearch.AStarNode","text":"AStarNode{TState, TCost}\n\nA node in the A* search tree, containing the state data and search metadata.\n\nFields\n\ndata::TState: The actual state data this node represents\ng::TCost: The cost from start to this node\nf::TCost: The total estimated cost (g + h) through this node to goal\nparent::Union{AStarNode{TState, TCost}, Nothing}: The predecessor node in the search tree\n\n\n\n\n\n","category":"type"},{"location":"api/#AStarSearch.AStarResult","page":"API Reference","title":"AStarSearch.AStarResult","text":"AStarResult{TState, TCost}\n\nResult of an A* search, containing the solution path and search statistics.\n\nFields\n\nstatus::Symbol: Search result - :success, :timeout, or :nopath\npath::Vector{TState}: Sequence of states from start to goal (or best found)\ncost::TCost: Total cost of the path\nclosedsetsize::Int64: Number of states explored (size of closed set)\nopensetsize::Int64: Number of states still to explore when search ended\n\n\n\n\n\n","category":"type"},{"location":"api/#AStarSearch.UninformedSearchResult","page":"API Reference","title":"AStarSearch.UninformedSearchResult","text":"UninformedSearchResult{TState}\n\nResult of an uninformed search algorithm (depth-first, breadth-first, or iterative deepening).\n\nFields\n\nstatus::Symbol: Search result - :success, :timeout, or :nopath\npath::Vector{TState}: Sequence of states from start to goal (or best found)\nclosedsetsize::Int64: Number of states explored (size of closed set)\nopensetsize::Int64: Number of states still to explore when search ended\n\n\n\n\n\n","category":"type"},{"location":"api/#AStarSearch.astar-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.astar","text":"astar(neighbours, start, goal;         heuristic=defaultheuristic, cost=defaultcost, isgoal=defaultisgoal, hashfn=hash, timeout=Inf, maxcost=Inf)\n\nExecute the A* algorithm to get the best path from the start state to reach a goal condition. Only the first 3 arguments are mandatory, all the others are optional.\n\nIt returns a structure in which the status field is a Symbol that can be either:\n\n:success: the algorithm found a path from start to goal\n:timeout: the algorithm timed out, a partial path to the best state is returned in the path field\n:nopath: the algorithm didn't find any path to a goal, the path to the best state is still returned\n\nThe other fields are:\n\npath: an array of states from the start state to the goal or the best found state\ncost: the cost of the returned path\nclosedsetsize: how many states the algorithm tested if they were a goal (size of the closed set)\nopensetsize: how many states were still in the open set when the algorithm ended\n\nArguments\n\nneighbours: a function that takes a state and returns the neighbour states as an array (or iterable)\nstart: the starting state, the type of the state is completely unrestricted\ngoal: the goal state, the type is unrestricted, usually it's the same as the start\nheuristic: a function that given a state and the goal returns an estimate of the cost to reach goal. This estimate should be optimistic if you want to be sure to get the best path. Notice that the best path could be very expensive to find, so if you want a good but not guaranteed optimal path, you could multiply your heuristic by a constant, the algorithm will usually be much faster\ncost: a function that takes the current state and a neighbour and returns the cost to do that state transition. By default all transitions cost 1\nisgoal: a function that takes a state and the goal and evaluates if the goal is reached (by default ==)\nhashfn: a function that takes a state and returns a compact representation to use as dictionary key (usually one of UInt, Int, String), by default it is the base hash function. This is a very important field for composite states in order to avoid duplications. WARNING states with arrays as fields might return a different hash every time! If this is the case, please pass an hashfn that always returns the same value for the same state!\ntimeout: timeout in number of seconds after which the algorithm stops returning the best partial path to the state with the lowest heuristic, by default it is unrestricted. Please notice that the algorithm wil run AT LEAST the specified time.\nmaxcost: a maximum bound of the accumulated cost of the path, this can result in a :nopath result even if a path to the goal (with a greater cost) exists. By default it is Inf\nenable_closedset: keep track of already visited nodes to avoid visiting them again, you might want to disable this if you know there isn't any loop in the state space graph (by default true)\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.breadthfirst-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.breadthfirst","text":"Executes a breadth first search given the neightbours function, the start and goal state.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.defaultcost-Tuple{Any, Any}","page":"API Reference","title":"AStarSearch.defaultcost","text":"defaultcost(state, neighbor) -> Int64\n\nDefault cost function used by A* search. Returns 1 for any state transition, making all moves equally costly. Override this for weighted edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.defaultheuristic-Tuple{Any, Any}","page":"API Reference","title":"AStarSearch.defaultheuristic","text":"defaultheuristic(state, goal) -> Int64\n\nDefault heuristic function used by A* search. Always returns 0, effectively reducing A* to Dijkstra's algorithm (or Breadth-First Search with unit costs). Override this with a problem-specific heuristic for better performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.defaultisgoal-Tuple{Any, Any}","page":"API Reference","title":"AStarSearch.defaultisgoal","text":"defaultisgoal(state, goal) -> Bool\n\nDefault goal test function used by A* search. Uses == to compare states. Override this for custom goal conditions or pattern matching.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.depthfirst-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.depthfirst","text":"Execute a depth-first search given the neighbours function, a start and a goal. It takes the same parameters as astar, but it ignores those about cost and heuristic. Use the maxdepth parameter to limit the search to a certain depth.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.iterative_deepening-Tuple{Any, Any, Any}","page":"API Reference","title":"AStarSearch.iterative_deepening","text":"Execute iteratively a depth first search starting from depth 0 to maxdepth.\n\n\n\n\n\n","category":"method"},{"location":"api/#AStarSearch.reconstructpath-Tuple{Any}","page":"API Reference","title":"AStarSearch.reconstructpath","text":"reconstructpath(node::AStarNode) -> Vector\n\nReconstructs the solution path by following parent pointers from the goal node back to the start node. Returns a vector of states in start-to-goal order.\n\nArguments\n\nnode: The final node (usually goal node) from which to reconstruct the path\n\nReturns\n\nVector of states representing the path from start to the final node\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isless-Tuple{AStarNode, AStarNode}","page":"API Reference","title":"Base.isless","text":"isless(n1::AStarNode, n2::AStarNode)\n\nCompare nodes by their f-values for priority queue ordering. Nodes with lower f-values (estimated total cost) are considered smaller.\n\n\n\n\n\n","category":"method"},{"location":"examples/15puzzle/#15-Puzzle-Example","page":"15-Puzzle","title":"15-Puzzle Example","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"The 15-puzzle is a classic sliding puzzle that consists of a 4Ã—4 grid with 15 numbered tiles and one empty space. The goal is to rearrange the tiles from a given starting configuration to reach a specific goal state by sliding tiles into the empty space.","category":"page"},{"location":"examples/15puzzle/#Problem-Setup","page":"15-Puzzle","title":"Problem Setup","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"First, we define the state structure and some helper functions:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"struct State\n    table::Array{Int8, 2}\nend\n\n# Define movement directions\nUP = CartesianIndex(-1, 0)\nDOWN = CartesianIndex(1, 0)\nLEFT = CartesianIndex(0, -1)\nRIGHT = CartesianIndex(0, 1)\nDIRECTIONS = [UP, DOWN, LEFT, RIGHT]\n\n# Goal state configuration\nGOALSTATE = State([\n    1  2  3  4\n    5  6  7  8\n    9  10 11 12\n    13 14 15 0\n])","category":"page"},{"location":"examples/15puzzle/#State-Manipulation","page":"15-Puzzle","title":"State Manipulation","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"We need functions to find valid moves and generate next states:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"# Find empty tile position\nemptyposition(s::State) = findfirst(x -> x == 0, s.table)\n\n# Check if a position is valid on the board\nisvalidindex(c) = (0 < c[1] < 5) && (0 < c[2] < 5)\n\n# Get available moves from current empty position\navailablemoves(e::CartesianIndex) = \n    [direction for direction in DIRECTIONS if isvalidindex(e + direction)]\navailablemoves(s::State) = s |> emptyposition |> availablemoves\n\n# Generate next states by applying available moves\nnextstates(s::State) = map(x -> move(s, x), availablemoves(s))","category":"page"},{"location":"examples/15puzzle/#Heuristic-Function","page":"15-Puzzle","title":"Heuristic Function","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"For efficient pathfinding, we use a combination of Manhattan distance and swap count:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"function heuristicmanhattanandswaps(s::State)\n    # Manhattan distance component\n    manhattan_sum = sum(manhattan(findfirst(x -> x == i, s.table), \n                                FINALSTATEINDEXES[i]) for i = 1:15)\n    \n    # Swap count component\n    swaps = countswaps(s)\n    \n    return manhattan_sum + 2*swaps\nend\n\n# For A* search interface\nheuristic(s, goal) = heuristicmanhattanandswaps(s)","category":"page"},{"location":"examples/15puzzle/#Solving-the-Puzzle","page":"15-Puzzle","title":"Solving the Puzzle","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"Now we can solve the puzzle using A* search:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"using AStarSearch\n\n# Example starting state\nstart = State([\n    1 2 3 4\n    5 7 11 8\n    9 6 0 12\n    13 10 14 15\n])\n\n# Find solution path\nresult = astar(nextstates, start, GOALSTATE; heuristic=heuristic)\n\nif result.status == :success\n    println(\"Solution found in $(result.cost) moves!\")\n    # Path contains the sequence of states from start to goal\n    for state in result.path\n        display(state.table)\n        println()\n    end\nelse\n    println(\"No solution found.\")\nend","category":"page"},{"location":"examples/15puzzle/#Performance-Considerations","page":"15-Puzzle","title":"Performance Considerations","text":"","category":"section"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"For efficient state comparison and storage in the closed set, we provide a custom hash function that compresses the entire board state into a single 64-bit integer:","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"function Base.hash(s::State)\n    h = UInt64(0)\n    for j = 1:4, i = 1:4\n        h += s.table[i, j]\n        h <<= 4\n    end\n    return h\nend","category":"page"},{"location":"examples/15puzzle/","page":"15-Puzzle","title":"15-Puzzle","text":"This example demonstrates how AStarSearch.jl can be used to solve complex puzzles while maintaining good performance through careful state representation and heuristic design.","category":"page"},{"location":"#AStarSearch.jl","page":"Home","title":"AStarSearch.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A generic implementation of the A* search algorithm and several uninformed search algorithms in Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generic A* search implementation that works with any state type\nCustomizable heuristic, cost, and neighbor functions\nMemory efficient with optional closed set\nAdditional uninformed search algorithms:\nDepth-first search\nBreadth-first search\nIterative deepening","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AStarSearch\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AStarSearch\n\n# Define how to get neighbors for your state\nneighbors(state) = # your neighbor generation logic\n\n# Optional: Define custom heuristic (defaults to 0)\nheuristic(state, goal) = # your heuristic function\n\n# Optional: Define custom cost function (defaults to 1)\ncost(state, neighbor) = # your cost function\n\n# Run A* search\npath = astar(neighbors, start_state, goal_state; \n             heuristic=heuristic, \n             cost=cost)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailed examples and usage, check out the Examples section.","category":"page"},{"location":"examples/maze/#Maze-Pathfinding-Example","page":"Maze Pathfinding","title":"Maze Pathfinding Example","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"This example shows how to use AStarSearch.jl to solve a simple maze pathfinding problem. We'll represent the maze as a 2D grid where true represents walls and false represents open paths.","category":"page"},{"location":"examples/maze/#Problem-Setup","page":"Maze Pathfinding","title":"Problem Setup","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"We'll use CartesianIndex to represent positions in the maze:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"# Define movement directions\nUP = CartesianIndex(-1, 0)\nDOWN = CartesianIndex(1, 0)\nLEFT = CartesianIndex(0, -1)\nRIGHT = CartesianIndex(0, 1)\nDIRECTIONS = [UP, DOWN, LEFT, RIGHT]","category":"page"},{"location":"examples/maze/#Neighbor-Generation","page":"Maze Pathfinding","title":"Neighbor Generation","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"For each position in the maze, we need to generate valid neighboring positions:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"function mazeneighbours(maze, p)\n    res = CartesianIndex[]\n    for d in DIRECTIONS\n        n = p + d\n        # Check if neighbor is within bounds and not a wall\n        if 1 â‰¤ n[1] â‰¤ size(maze)[1] && \n           1 â‰¤ n[2] â‰¤ size(maze)[2] && \n           !maze[n]\n            push!(res, n)\n        end\n    end\n    return res\nend","category":"page"},{"location":"examples/maze/#Heuristic-Function","page":"Maze Pathfinding","title":"Heuristic Function","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"We'll use Manhattan distance as our heuristic:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"manhattan(p, s) = abs(p[1] - s[1]) + abs(p[2] - s[2])","category":"page"},{"location":"examples/maze/#Solving-the-Maze","page":"Maze Pathfinding","title":"Solving the Maze","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"Putting it all together:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"using AStarSearch\n\n# Create a maze (true = wall, false = path)\nmaze = [\n    0 0 1 0 0\n    0 1 0 0 0\n    0 1 0 0 1\n    0 0 0 1 1\n    1 0 1 0 0\n] .== 1\n\n# Define start and goal positions\nstart = CartesianIndex(1, 1)\ngoal = CartesianIndex(1, 5)\n\n# Helper function to solve the maze\nfunction solvemaze(m, s, g)\n    astar(p -> mazeneighbours(m, p), s, g; heuristic=manhattan)\nend\n\n# Find the path\nresult = solvemaze(maze, start, goal)\n\nif result.status == :success\n    println(\"Path found with length $(result.cost)!\")\n    # Print the path\n    for position in result.path\n        println(position)\n    end\nelse\n    println(\"No path found to goal!\")\nend","category":"page"},{"location":"examples/maze/#Visualizing-the-Solution","page":"Maze Pathfinding","title":"Visualizing the Solution","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"Here's a simple way to visualize the path in the maze:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"function printmaze(maze, path)\n    chars = fill('.', size(maze))\n    chars[maze] .= 'â–ˆ'\n    \n    # Mark the path with numbers\n    for (i, pos) in enumerate(path)\n        chars[pos] = '*'\n    end\n    \n    # Print the maze\n    for row in eachrow(chars)\n        println(join(row))\n    end\nend\n\n# Example visualization\nprintmaze(maze, result.path)","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"This will produce output like:","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"*....\n*â–ˆ*.\n*â–ˆ*.â–ˆ\n**.â–ˆâ–ˆ\nâ–ˆ*â–ˆ..","category":"page"},{"location":"examples/maze/","page":"Maze Pathfinding","title":"Maze Pathfinding","text":"This example demonstrates how AStarSearch.jl can be used for grid-based pathfinding problems. The same approach can be extended to more complex grids, different movement patterns, or custom cost functions.","category":"page"}]
}
